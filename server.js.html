<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: server.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: server.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import 'dotenv/config';
import { handler } from "./build/handler.js";
import express from 'express';
import session from 'express-session';
import passport from 'passport';
import bodyParser from 'body-parser';
import cookieParser from 'cookie-parser';
import cron from 'node-cron';
import { v4 as uuidv4 } from 'uuid';
import { sequelize, Op, Classroom, Quiz, QuizStudent, ClassroomStudents, ProgUser } from './models.js';
import './passport.js';
import redis from 'redis';
import { RedisStore } from "connect-redis";
/** Redis session storage
*/
if (!(process.env.DEV === "true")) {
    /** Create new redis client */
    var redisClient = redis.createClient({
        url: process.env.REDIS_ENDPOINT,
        password: process.env.REDIS_PASSWORD,
        socket: { tls: true, rejectUnauthorized: false }
    });
    /** Attach extensive logging on Redis client events */
    redisClient.on('connect', () => console.log('[Redis] Client connected.'));
    redisClient.on('ready', () => console.log('[Redis] Client ready to use.'));
    redisClient.on('reconnecting', () => console.log('[Redis] Reconnecting...'));
    redisClient.on('end', () => console.log('[Redis] Client connection closed.'));
    redisClient.on('error', (err) => console.error('[Redis] Client Error:', err));
    (async () => {
        console.log('[Redis] Attempting to connect...');
        try {
            await redisClient.connect();
            console.log('[Redis] Connected successfully.');
        }
        catch (err) {
            console.error('[Redis] Could not connect:', err);
        }
    })();
}
/** Create the express app */
const app = express();
app.use(bodyParser.json()); // Parse JSON request bodies
app.use(cookieParser()); // Parse cookies
/** Get the session secret from the environment */
const sessionSecret = String(process.env.GOOGLE_CLIENT_SECRET);
/** Check if we are in development or production, use either the basic express session or redis
 * @function startSession
*/
if ((process.env.DEV === "true")) {
    app.use(session({
        secret: sessionSecret,
        resave: true,
        saveUninitialized: true
    }));
}
else {
    app.use(session({
        store: new RedisStore({ client: redisClient }),
        secret: sessionSecret,
        resave: true,
        saveUninitialized: true,
        cookie: {
            secure: false, // Set to true if using HTTPS
            httpOnly: true,
            maxAge: 1000 * 60 * 30, // Session expires after 30 minutes
        },
    }));
}
/** Use passport for authentication
 */
app.use(passport.initialize());
app.use(passport.session());
/** Google Authentication
 * @function googleAuthentication
 */
app.get('/auth/google', (req, res, next) => {
    /** Get the position of the user that is signing in, it is either 'student' or 'teacher' */
    const position = String(req.query.position);
    if (position !== 'teacher' &amp;&amp; position !== 'student') {
        res.status(400).json({ error: 'Invalid position' });
    }
    if (!req.session) {
        res.status(500).json({ error: 'Session not initialized' });
    }
    /** Save the position to session to be accessed by passport */
    req.session.position = position;
    next();
    /** Pass on to passport */
}, passport.authenticate('google', { scope: ['profile', 'email'] }));
/** Endpoint for the callback after authentication has completed
 * @function googleAuthenticationCallback
 */
app.get('/auth/google/callback', 
/** Authenticate with passport */
passport.authenticate('google', { failureRedirect: '/' }), 
/** Redirect to correct starting page according to position */
function (req, res) {
    if (req.user.position === 'teacher') {
        res.redirect('/teacher_classroom_list');
    }
    else {
        res.redirect('/student_classroom_list');
    }
});
/** Get classrooms by teacher to be used in endpoint
 * @function getClassroomsByTeacher
 */
const getClassroomsByTeacher = async (teacherId) => {
    try {
        const classrooms = await Classroom.findAll({
            where: {
                teacher_id: teacherId,
            },
        });
        return classrooms;
    }
    catch (error) {
        console.error('Error fetching classrooms:', error);
        throw error;
    }
};
/** Get all the classrooms by teacher
 * @function getClassroomsByTeacher
*/
app.get('/getClassroomsByTeacher', async (req, res) => {
    /** At the start of each endpoint we check authentication using the users cookie and serialised data */
    if (req.user !== undefined &amp;&amp; req.isAuthenticated()) {
        const teacherId = String(req.user.googleId);
        try {
            /** Simply use the previous function */
            const classrooms = await getClassroomsByTeacher(teacherId);
            res.json(classrooms);
        }
        catch (error) {
            console.error('Error fetching classrooms:', error);
            res.status(500).json({ error: 'Internal Server Error' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Get all the classrooms by student email endpoint
 * @function getClassroomsByStudent
 */
app.get('/getClassroomsByStudent', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated()) {
        /** We search based on the students email */
        const studentEmail = String(req.user.email);
        try {
            /** Get all the connections between student and classroom where the email matches */
            const classroomStudents = await ClassroomStudents.findAll({
                where: { f_student_email: studentEmail }
            });
            /** Map the connections to the corresponding classroom id */
            const classroomIds = classroomStudents.map(classroom => classroom.f_classroom_id);
            /** Get all the classrooms based on their ids */
            const classrooms = await Promise.all(classroomIds.map(id => Classroom.findOne({ where: { id } })));
            res.json(classrooms);
        }
        catch (error) {
            console.error('Error fetching classrooms:', error);
            res.status(500).json({ error: 'Internal Server Error' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Student Section */
/** Function to get all the students in a classroom */
const getStudentsByClassroom = async (classroomId) => {
    try {
        /** Get all the connections between student and classroom where the provided classroom id matches */
        const studentClassroomConnections = await ClassroomStudents.findAll({
            where: {
                f_classroom_id: classroomId,
            },
        });
        /** For each connection found, get the the corresponding student */
        var students = [];
        for (const connection of studentClassroomConnections) {
            let student = await ProgUser.findAll({
                where: { email: connection.f_student_email }
            });
            /** If we managed to find one we return him  */
            if (student.length > 0) {
                students.push(student[0]);
            }
        }
        return students;
    }
    catch (error) {
        console.error('Error fetching students by classroom:', error);
        throw error;
    }
};
/** Endpoint to get all the students in a classroom by the classroom id
* @function getStudentsByClassroom
 */
app.get('/getStudentsByClassroom', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated()) {
        const classroomId = Number(req.query.classroomId);
        if (isNaN(classroomId)) {
            res.status(500).json({ error: "We need a number" });
        }
        try {
            const students = await getStudentsByClassroom(classroomId);
            res.json(students);
        }
        catch (error) {
            console.error('Error fetching students by classroom:', error);
            res.status(500).json({ error: 'Internal Server Error' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Endpoint to add students en masse to a classroom
* @function addStudentsToClassroom
 */
app.post('/addStudentsToClassroom', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "teacher") {
        try {
            const studentList = req.body.studentList;
            const currentClassroom = req.body.currentClassroom;
            /** For each student we create a promise that we then execute  */
            const insertPromises = studentList.map(async (studentEmail) => {
                /** If user does not already exist, create him */
                const [user, created] = await ProgUser.findOrCreate({
                    where: { email: studentEmail, position: 'student' },
                    defaults: {
                        googleId: uuidv4(), // Chance of collision 1 in 2^212 apparently 
                        name: 'Pending',
                        profilePicture: null,
                        position: 'student',
                        isPending: true,
                    }
                });
                /** Create the corresponding connection between studen and classroom */
                await ClassroomStudents.create({
                    f_classroom_id: Number(currentClassroom),
                    f_student_email: String(studentEmail)
                });
                /** Get all the quizzes in the classsroom, since we need to assign them to the new student */
                const quizzes = await Quiz.findAll({
                    where: {
                        f_classroom_id: currentClassroom
                    }
                });
                /** For each quiz we create the corresponding connection with the student */
                for (const quiz of quizzes) {
                    let created = await QuizStudent.create({
                        f_student_email: studentEmail,
                        f_quiz_id: quiz.id,
                        answered: false,
                        max_points: quiz.max_points
                    });
                }
            });
            /** Execute all the created promises */
            await Promise.all(insertPromises);
            res.status(201).json({ message: 'Students added to classroom successfully' });
        }
        catch (error) {
            console.error('Error adding students to classroom:', error);
            res.status(500).json({ error: 'Failed to add students to classroom' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Remove a student from a classroom endpoint */
app.post('/removeStudentFromClassroom', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "teacher") {
        try {
            const classroomId = req.body.classroomId;
            const studentEmail = req.body.studentEmail;
            const studentId = req.body.studentId;
            /** Destroy the connection between the student and the classroom */
            let destroyed = await ClassroomStudents.destroy({
                where: { f_classroom_id: classroomId, f_student_email: studentEmail },
            });
            if (destroyed) {
                /** If wee succeed we find all the quizzes in the classroom, so that we can unassign them from the student */
                const ClassroomQuizes = await Quiz.findAll({ where: { f_classroom_id: classroomId }
                });
                /** Delete all the connections between the quizzes in the classroom and the student being removed  */
                for (const quiz of ClassroomQuizes) {
                    destroyed = await QuizStudent.destroy({
                        where: { f_quiz_id: quiz.id, f_student_email: studentEmail }
                    });
                }
                res.status(201).json({ message: 'Student removed successfully' });
            }
            else {
                res.status(500).json({ error: 'Failed to remove student' });
            }
        }
        catch (error) {
            console.error('Error removing student:', error);
            res.status(500).json({ error: 'Failed to remove student' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Quiz section */
/** Get all the quizzes that a student has assigned within a specific classroom
* @function getQuizzesByStudentAndClassroom
 */
app.get('/getQuizzesByStudentAndClassroom', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated()) {
        const currentClassroom = Number(req.query.currentClassroom);
        const studentEmail = String(req.user.email);
        try {
            /** Find all the quiz connection that the student has */
            const studentQuizzes = await QuizStudent.findAll({
                where: { f_student_email: studentEmail }
            });
            /** Map the quizzes that we found to their ids */
            const quizIds = studentQuizzes.map(quizStudent => quizStudent.f_quiz_id);
            /** Since we do not have information about the classroom withing the connection between a student and a quiz, we check each quiz if it is in the corresponding classroom  */
            let quizzes = await Promise.all(quizIds.map(f_quiz_id => Quiz.findOne({ where: { id: f_quiz_id, f_classroom_id: currentClassroom } })));
            quizzes = quizzes.filter(quiz => quiz !== null);
            res.json(quizzes);
        }
        catch (error) {
            console.error('Error fetching quizzes:', error);
            res.status(500).json({ error: 'Internal Server Error' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Get a single connection between a student and a quiz
* @function getQuizStudentConnection
 */
app.get('/getQuizStudentConnection', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated()) {
        const studentEmail = req.query.studentEmail ? String(req.query.studentEmail) : String(req.user.email);
        const quizId = Number(req.query.quizId);
        try {
            /** Fin the corresponding connection between a student and a quiz based on the email and the quizId */
            const studentQuizConnection = await QuizStudent.findOne({
                where: { f_student_email: studentEmail, f_quiz_id: quizId }
            });
            res.json(studentQuizConnection);
        }
        catch (error) {
            console.error('Error fetching studentQuizConnection:', error);
            res.status(500).json({ error: 'Internal Server Error' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Get multiple quiz student connections based off of student email and array of quiz ids
* We use this because when we have a quiz object and a student object, we need the corresponding information between them
* @function getQuizStudentConnectionsByQuizIds
 */
app.get('/getQuizStudentConnectionsByQuizIds', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated()) {
        const studentEmail = String(req.user.email);
        const quizIdArray = String(req.query.quizIds).split(',').map(stringid => Number(stringid));
        try {
            /** Get all the connections between the quizzes and the student s */
            const connectionArray = await Promise.all(quizIdArray.map(async (quizId) => {
                const studentQuizConnection = await QuizStudent.findOne({
                    where: { f_student_email: studentEmail, f_quiz_id: quizId }
                });
                return studentQuizConnection;
            }));
            res.json(connectionArray);
        }
        catch (error) {
            console.error('Error fetching studentQuizConnection:', error);
            res.status(500).json({ error: 'Internal Server Error' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Get multiple quiz student connection based off of quiz id and array of student emails
* Used to display all the students who have answered a quiz in the teacher section
* @function getQuizStudentConnectionsByStudentEmails
 */
app.get('/getQuizStudentConnectionsByStudentEmails', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated()) {
        const quizId = Number(req.query.quizId);
        const studentEmails = String(req.query.studentEmails).split(',');
        try {
            /** Get all the corresponding connections */
            const connectionArray = await Promise.all(studentEmails.map(async (studentEmail) => {
                const studentQuizConnection = await QuizStudent.findOne({
                    where: { f_student_email: studentEmail, f_quiz_id: quizId }
                });
                return studentQuizConnection;
            }));
            res.json(connectionArray);
        }
        catch (error) {
            console.error('Error fetching studentQuizConnection:', error);
            res.status(500).json({ error: 'Internal Server Error' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Get a quiz object by its id
* @function getQuizById
 */
app.get('/getQuizById', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated()) {
        const quizId = Number(req.query.quizId);
        try {
            const quiz = await Quiz.findOne({
                where: { id: quizId }
            });
            res.json(quiz);
        }
        catch (error) {
            console.error('Error fetching quiz:', error);
            res.status(500).json({ error: 'Internal Server Error' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Submit a student's answer to a quiz endpoint
* @function submitQuizAnswer
 */
app.post('/submitQuizAnswer', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "student") {
        try {
            const studentEmail = String(req.user.email);
            const quizId = Number(req.body.quizId);
            const answerText = String(req.body.answerText); // The student's answer
            const [affectedCount] = await QuizStudent.update({ answered: true, answer: answerText }, { where: { f_student_email: studentEmail, f_quiz_id: quizId }
            });
            /** If the update went through for one instance, it was successful */
            if (affectedCount === 1) {
                res.status(201).json({ message: 'Submitted successfully' });
            }
            else {
                res.status(500).json({ error: 'Failed to submit quiz' });
            }
        }
        catch (error) {
            console.error('Error submitting quiz', error);
            res.status(500).json({ error: 'Failed to submit' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Unsubmit a students answer endpoint
* @function unsubmitQuizAnswer
 */
app.post('/unsubmitQuizAnswer', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "student") {
        try {
            const studentEmail = String(req.user.email);
            const quizId = Number(req.body.quizId);
            const [affectedCount] = await QuizStudent.update({ answered: false }, { where: { f_student_email: studentEmail, f_quiz_id: quizId }
            });
            /** If the update went through for one instance, it was successful */
            if (affectedCount === 1) {
                res.status(201).json({ message: 'Unsubmitted successfully' });
            }
            else {
                res.status(500).json({ error: 'Failed to unsubmit quiz' });
            }
        }
        catch (error) {
            console.error('Error unsubmitting quiz', error);
            res.status(500).json({ error: 'Failed to unsubmit' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Submit a teacher's comment to a quiz endpoint
* @function submitQuizComment
 */
app.post('/submitQuizComment', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "teacher") {
        try {
            const studentEmail = String(req.body.studentEmail);
            const quizId = Number(req.body.quizId);
            const commentText = String(req.body.commentText);
            const points = Number(req.body.points);
            const [affectedCount] = await QuizStudent.update({ graded: true, comment: commentText, points: points }, { where: { f_student_email: studentEmail, f_quiz_id: quizId }
            });
            /** If the update affected one instance, it was successful */
            if (affectedCount === 1) {
                res.status(201).json({ message: 'Submitted successfully' });
            }
            else {
                res.status(500).json({ error: 'Failed to submit quiz' });
            }
        }
        catch (error) {
            console.error('Error submitting quiz', error);
            res.status(500).json({ error: 'Failed to submit' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Unsubmit a teacher's comment to a quiz endpoint
* @function unsubmitQuizComment
 */
app.post('/unsubmitQuizComment', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "teacher") {
        try {
            const studentEmail = String(req.body.studentEmail);
            const quizId = Number(req.body.quizId);
            const [affectedCount] = await QuizStudent.update({ graded: false }, { where: { f_student_email: studentEmail, f_quiz_id: quizId }
            });
            /** If the update affected one instance, it was successful */
            if (affectedCount === 1) {
                res.status(201).json({ message: 'Unubmitted successfully' });
            }
            else {
                res.status(500).json({ error: 'Failed to unsubmit quiz' });
            }
        }
        catch (error) {
            console.error('Error unsubmitting quiz', error);
            res.status(500).json({ error: 'Failed to unsubmit' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Classroom section */
/** Add a classroom endpoint
* @function addClassroom
 */
app.post('/addClassroom', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "teacher") {
        try {
            const classroomName = req.body.classroomString;
            const teacherId = req.user.googleId;
            /** Creat a classroom based on the name provided by the teacher */
            Classroom.create({
                name: String(classroomName),
                teacher_id: String(teacherId)
            }).then(student => {
                console.log('Inserted:', student.toJSON());
            })
                .catch(err => console.error('Error:', err));
            res.status(201).json({ message: 'Students added to classroom successfully' });
        }
        catch (error) {
            console.error('Error adding students to classroom:', error);
            res.status(500).json({ error: 'Failed to add students to classroom' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Remove a classroom based on the id endpoint */
app.post('/removeClassroom', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "teacher") {
        try {
            const classroomId = Number(req.body.classroomId);
            let destroyed = await Classroom.destroy({
                where: { id: classroomId },
            });
            if (destroyed) {
                /** Destroy the quizzes associated with it  */
                destroyed = await Quiz.destroy({ where: { f_classroom_id: classroomId }
                });
                /** Destroy the student connections associated with it */
                destroyed = await ClassroomStudents.destroy({ where: { f_classroom_id: classroomId }
                });
                res.status(201).json({ message: 'Classroom removed successfully' });
            }
            else {
                res.status(500).json({ error: 'Failed to remove classroom' });
            }
        }
        catch (error) {
            console.error('Error removing classroom:', error);
            res.status(500).json({ error: 'Failed to remove classroom' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Quiz section */
/** Get Quizes in classroom by the classroom id   */
const getQuizesByClassroom = async (classroomId) => {
    try {
        const quizes = await Quiz.findAll({
            where: {
                f_classroom_id: classroomId,
            },
        });
        return quizes;
    }
    catch (error) {
        console.error('Error fetching classrooms:', error);
        throw error;
    }
};
/** Get Quizes in classroom by the classroom id endpoint
* @function getQuizesByClassroom
 */
app.get('/getQuizesByClassroom', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated()) {
        const classroomId = Number(req.query.classroomId);
        if (isNaN(classroomId)) {
            res.status(500).json({ error: "We need a number" });
        }
        try {
            const quizzes = await getQuizesByClassroom(classroomId);
            res.json(quizzes);
        }
        catch (error) {
            console.error('Error fetching classrooms:', error);
            res.status(500).json({ error: 'Internal Server Error' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Add a quiz to a classroom by the classroom id endpoint
* @function addQuizToClassroom
 */
app.post('/addQuizToClassroom', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "teacher") {
        try {
            const currentClassroom = Number(req.body.currentClassroom);
            const quizName = req.body.quizName;
            const quizQuestion = req.body.quizQuestion;
            const quizType = req.body.quizType; // Two types of quizzes
            const closeAt = req.body.closeAt;
            const maxPoints = Number(req.body.maxPoints);
            /** Create the quiz  */
            const createdQuiz = await Quiz.create({
                name: String(quizName),
                question: String(quizQuestion),
                type: quizType,
                f_classroom_id: currentClassroom,
                closeAt: String(closeAt),
                open: true,
                max_points: maxPoints
            });
            /** Find all the students in the classroom */
            const students = await ClassroomStudents.findAll({
                where: {
                    f_classroom_id: currentClassroom
                }
            });
            /** For each student in the classroom creata quiz student connection that assigns them the quiz */
            for (const student of students) {
                await QuizStudent.create({
                    f_quiz_id: createdQuiz.id,
                    f_student_email: student.f_student_email,
                    answered: false,
                    max_points: maxPoints
                });
            }
            res.status(201).json({ message: 'Quiz added successfully' });
        }
        catch (error) {
            console.error('Error adding Quiz:', error);
            res.status(500).json({ error: 'Failed to add quiz' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Remove a quiz from a classroom endpoint */
app.post('/removeQuiz', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "teacher") {
        try {
            const quizId = Number(req.body.quizId);
            let destroyed = await QuizStudent.destroy({
                where: {
                    f_quiz_id: quizId
                }
            });
            if (destroyed) {
                /** Destroy the quiz */
                destroyed = await Quiz.destroy({
                    where: { id: quizId },
                });
                res.status(201).json({ message: 'Quiz removed successfully' });
            }
            else {
                res.status(500).json({ error: 'Failed to remove quiz' });
            }
        }
        catch (error) {
            console.error('Error removing quiz:', error);
            res.status(500).json({ error: 'Failed to remove quiz' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Close the quiz by its id endpoint  */
app.post('/closeQuiz', async (req, res) => {
    if (req.user !== undefined &amp;&amp; req.isAuthenticated() &amp;&amp; req.user.position === "teacher") {
        try {
            const quizId = Number(req.body.quizId);
            /** Update the quiz open attribute */
            await Quiz.update({ open: false }, {
                where: {
                    id: quizId
                }
            });
            res.status(201).json({ message: "Quiz successfuly closed" });
        }
        catch (error) {
            console.error('Error removing quiz:', error);
            res.status(500).json({ error: 'Failed to remove quiz' });
        }
    }
    else {
        res.status(403).json({ error: "Unauthorized" });
    }
});
/** Error logging for express */
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Internal Server Error' });
});
/** Tell express to load the files from the client */
app.use(express.static('build/client'));
/** Eats all the remaining routes */
app.use(handler);
/** For debuggin to print all paths  */
app._router.stack.forEach((middleware) => {
    if (middleware.route) {
        console.log(middleware.route.path);
    }
    else if (middleware.name === 'router') {
        middleware.handle.stack.forEach((handler) => {
            if (handler.route) {
                console.log(handler.route.path);
            }
        });
    }
});
/** Schedule quiz closing, runs every minute to see if a quiz has been closed */
cron.schedule('* * * * *', async () => {
    try {
        const nowISO = new Date().toISOString();
        /** Update quizzes that are still open but whose closeAt timestamp has passed */
        const [updatedCount] = await Quiz.update({ open: false }, {
            where: {
                open: true,
                closeAt: {
                    [Op.lte]: nowISO
                }
            }
        });
        if (updatedCount) {
            console.log(`Closed ${updatedCount} expired quizzes.`);
        }
    }
    catch (error) {
        console.error('Error closing expired quizzes:', error);
    }
});
/** Set the port based on development or production */
let port = Number(process.env.PORT) || 3000;
app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}`);
});
//# sourceMappingURL=server.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Classroom.html">Classroom</a></li><li><a href="ClassroomStudents.html">ClassroomStudents</a></li><li><a href="ProgUser.html">ProgUser</a></li><li><a href="Quiz.html">Quiz</a></li><li><a href="QuizStudent.html">QuizStudent</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addClassroom">addClassroom</a></li><li><a href="global.html#addQuizToClassroom">addQuizToClassroom</a></li><li><a href="global.html#addStudentsToClassroom">addStudentsToClassroom</a></li><li><a href="global.html#app">app</a></li><li><a href="global.html#getClassroomsByStudent">getClassroomsByStudent</a></li><li><a href="global.html#getClassroomsByTeacher">getClassroomsByTeacher</a></li><li><a href="global.html#getQuizById">getQuizById</a></li><li><a href="global.html#getQuizStudentConnection">getQuizStudentConnection</a></li><li><a href="global.html#getQuizStudentConnectionsByQuizIds">getQuizStudentConnectionsByQuizIds</a></li><li><a href="global.html#getQuizStudentConnectionsByStudentEmails">getQuizStudentConnectionsByStudentEmails</a></li><li><a href="global.html#getQuizesByClassroom">getQuizesByClassroom</a></li><li><a href="global.html#getQuizzesByStudentAndClassroom">getQuizzesByStudentAndClassroom</a></li><li><a href="global.html#getStudentsByClassroom">getStudentsByClassroom</a></li><li><a href="global.html#googleAuthentication">googleAuthentication</a></li><li><a href="global.html#googleAuthenticationCallback">googleAuthenticationCallback</a></li><li><a href="global.html#port">port</a></li><li><a href="global.html#redisClient">redisClient</a></li><li><a href="global.html#sessionSecret">sessionSecret</a></li><li><a href="global.html#startSession">startSession</a></li><li><a href="global.html#submitQuizAnswer">submitQuizAnswer</a></li><li><a href="global.html#submitQuizComment">submitQuizComment</a></li><li><a href="global.html#unsubmitQuizAnswer">unsubmitQuizAnswer</a></li><li><a href="global.html#unsubmitQuizComment">unsubmitQuizComment</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Mar 11 2025 16:48:48 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
